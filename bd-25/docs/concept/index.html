<!DOCTYPE html><html data-theme="dark"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content="false"><meta name="author" content="MDXpress"><title></title><link rel="icon" type="image/svg+xml" href="/bd-25/favicon.svg"><link rel="stylesheet" href="/bd-25/_astro/_slug_.FGKI9IMe.css"></head> <body> <div class="app"> <nav class="navigation"> <h1 class="navigation-header">docs</h1> <hr> <ul class="tree"> <li class="tree-node"> <a href="/bd-25/docs/architecture" class="tree-link"> <span class="tree-file-icon"></span> ARCHITECTURE.md </a>  </li><li class="tree-node"> <a href="/bd-25/docs/assets" class="tree-link"> <span class="tree-file-icon"></span> ASSETS.mdx </a>  </li><li class="tree-node"> <a href="/bd-25/docs/biomes" class="tree-link"> <span class="tree-file-icon"></span> BIOMES.md </a>  </li><li class="tree-node"> <a href="/bd-25/docs/collectibles" class="tree-link"> <span class="tree-file-icon"></span> COLLECTIBLES.md </a>  </li><li class="tree-node"> <a href="/bd-25/docs/concept" class="tree-link active"> <span class="tree-file-icon"></span> CONCEPT.mdx </a>  </li><li class="tree-node"> <a href="/bd-25/docs/crafting" class="tree-link"> <span class="tree-file-icon"></span> CRAFTING.md </a>  </li><li class="tree-node"> <a href="/bd-25/docs/features" class="tree-link"> <span class="tree-file-icon"></span> FEATURES.md </a>  </li><li class="tree-node"> <a href="/bd-25/docs/performance" class="tree-link"> <span class="tree-file-icon"></span> PERFORMANCE.md </a>  </li><li class="tree-node"> <a href="/bd-25/docs/persistence" class="tree-link"> <span class="tree-file-icon"></span> PERSISTENCE.md </a>  </li><li class="tree-node"> <a href="/bd-25/docs/readme" class="tree-link"> <span class="tree-file-icon"></span> README.md </a>  </li><li class="tree-node"> <a href="/bd-25/docs/testing" class="tree-link"> <span class="tree-file-icon"></span> TESTING.md </a>  </li> </ul> </nav> <main class="main-content"> <div class="doc-content"> <h1 id="-amelcraft-a-kid-friendly-2d-minecraft-inspired-game">üìù Amelcraft: A Kid-Friendly 2D Minecraft-Inspired Game</h1>
<h2 id="-project-evolution">üîÑ Project Evolution</h2>
<p>The project began as a birthday idea for a 7-year-old, inspired by the Minecraft hype but aiming for simplicity and accessibility. The concept evolved from a general 2D block-building game to a focused, responsive, cross-device experience using Phaser.js. Early discussions weighed complexity (e.g., day/night cycles, pathfinding) against the need for a fun, easy-to-play game. The design journey included debates about control schemes, building mechanics, and the choice between 2D and simulated 3D, ultimately favoring a top-down, grid-based approach for ease of use and development.</p>
<h2 id="-project-genesis--motivation">üöÄ Project Genesis &amp; Motivation</h2>
<p>The motivation was personal: to create a custom game for a child‚Äôs birthday, capturing the excitement of Minecraft in a form approachable for a young beginner. The project was inspired by the child‚Äôs fascination with Minecraft and the desire to provide a creative, interactive experience tailored to her age and skills. The goal was to foster creativity, exploration, and fun, while keeping technical and gameplay complexity low.</p>
<h2 id="-project-overview">üöÄ Project Overview</h2>
<p>Amelcraft is a simple, 2D, tile-based game where players can harvest materials and place blocks in a world reminiscent of Minecraft. Designed for both desktop and mobile, it features responsive controls and adaptive camera zoom, ensuring a smooth experience across devices. The game is intended for young children, with intuitive drag-to-move controls and straightforward block placement.</p>
<h2 id="-core-ideas--features">üí° Core Ideas &amp; Features</h2>
<ul>
<li><strong>2D Tile-Based World:</strong> The game world is a grid of 48x48px tiles.</li>
<li><strong>Harvesting &amp; Placing Blocks:</strong> Players collect materials and place blocks on the grid.</li>
<li><strong>Drag-to-Move Controls:</strong> Movement is controlled by dragging on the screen (touch or mouse).</li>
<li><strong>Responsive Design:</strong> The game adapts to device size and orientation, with dynamic camera zoom.</li>
<li><strong>Simple Inventory:</strong> Materials collected are stored and can be selected for placement.</li>
<li><strong>Single-File POC:</strong> Initial proof-of-concept provided as a single HTML file for easy testing.</li>
</ul>
<h2 id="-design-decisions--rationale">üß© Design Decisions &amp; Rationale</h2>
<ul>
<li><strong>Phaser.js Chosen:</strong> For rapid development and cross-platform support.</li>
<li><strong>Drag-to-Move Over Click-to-Move:</strong> Simpler for young children, avoids pathfinding complexity.</li>
<li><strong>Top-Down (Horizontal) Building:</strong> More intuitive for kids, easier to implement than vertical or 3D.</li>
<li><strong>Responsive Canvas &amp; Camera Zoom:</strong> Ensures playability on all devices, keeps sprites visible and detailed.</li>
<li><strong>No Day/Night Cycle:</strong> Dropped for simplicity.</li>
<li><strong>Block Placement Logic:</strong> Grid-based, with pointer-to-tile conversion for intuitive interaction.</li>
</ul>
<h2 id="-rejected-ideas--alternatives">‚ùå Rejected Ideas &amp; Alternatives</h2>
<ul>
<li><strong>Day/Night Cycle:</strong> Rejected to keep the game simple.</li>
<li><strong>Click-to-Move with Pathfinding:</strong> Considered but dropped due to complexity.</li>
<li><strong>3D or Isometric Building:</strong> Rejected for technical and cognitive simplicity; 2D chosen.</li>
<li><strong>Vertical (Wall) Building:</strong> Considered, but horizontal (ground) building selected for accessibility.</li>
</ul>
<h2 id="Ô∏è-player-vs-team-focus-debate">‚öñÔ∏è Player vs. Team Focus Debate</h2>
<p>The game is designed as a single-player experience, focused on individual creativity and exploration. Team or multiplayer features were not prioritized, given the target audience and scope.</p>
<h2 id="-personalinspirational-details">üåè Personal/Inspirational Details</h2>
<p>The project was inspired by a child‚Äôs birthday and her fascination with Minecraft. The design choices reflect a desire to create a fun, approachable experience tailored to her interests and abilities.</p>
<h2 id="-key-conversation-excerpts">üí¨ Key Conversation Excerpts</h2>
<blockquote>
<p>‚ÄúFor my daughter‚Äôs 7th birthday I want to make her a little video game, using phaser.js‚Ä¶simple 2D, sprite and tilemap based game, in which she can harvest a few materials and then place blocks from these materials in the world.‚Äù</p>
</blockquote>
<blockquote>
<p>‚ÄúI want the game to run on a desktop, as well as a mobile phone‚Ä¶controllable by touch/mouse click and the game screen and camera zoom level should adapt itself to the device.‚Äù</p>
</blockquote>
<blockquote>
<p>‚ÄúFor simplicity and a smooth experience for a 7-year-old, Option 2 (drag-to-move) is best. It‚Äôs easy to implement in Phaser, and kids enjoy direct control.‚Äù</p>
</blockquote>
<blockquote>
<p>‚ÄúFor a Minecraft-like experience and simplicity for a child, the horizontal plane (top-down) is best. It‚Äôs intuitive, easy to control, and lets your daughter ‚Äòwalk‚Äô over her creations.‚Äù</p>
</blockquote>
<h2 id="Ô∏è-architecture--structure">üèóÔ∏è Architecture &amp; Structure</h2>
<ul>
<li><strong>Phaser.js Engine:</strong> Handles rendering, input, and game logic.</li>
<li><strong>Responsive Canvas:</strong> Uses Phaser‚Äôs scale manager for device adaptation.</li>
<li><strong>Camera Zoom Logic:</strong> Dynamically calculates zoom based on screen size and tile size.</li>
<li><strong>Player Sprite:</strong> Controlled via drag-to-move pointer events.</li>
<li><strong>Tile Grid:</strong> 2D array represents the world; block placement updates the grid and renders sprites.</li>
<li><strong>Inventory System:</strong> Simple array for collected materials and block selection.</li>
</ul>
<h2 id="-code-snippets--examples">üíª Code Snippets &amp; Examples</h2>
<h3 id="responsive-game-screen--zoom">Responsive Game Screen &amp; Zoom</h3>
<style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="skaKJ" component-url="/bd-25/_astro/Code.kjOHE-K0.js" component-export="default" renderer-url="/bd-25/_astro/client.BIF7rNY7.js" props="{&quot;src&quot;:[0,{&quot;vanilla-ts&quot;:[0,{&quot;index.html&quot;:[0,&quot;&lt;!DOCTYPE html&gt;\n&lt;html lang=\&quot;en\&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=\&quot;UTF-8\&quot; /&gt;\n    &lt;title&gt;Responsive Phaser POC&lt;/title&gt;\n    &lt;script src=\&quot;https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js\&quot;&gt;&lt;/script&gt;\n    &lt;style&gt;\n      html,\n      body {\n        height: 100%;\n        margin: 0 !important;\n        padding: 0 !important;\n        overflow: hidden;\n        background: #222;\n      }\n      #game-container {\n        width: 100vw;\n        height: 100vh;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body style=\&quot;margin: 0; padding: 0\&quot;&gt;\n    &lt;div id=\&quot;game-container\&quot;&gt;&lt;/div&gt;\n    &lt;script src=\&quot;index.ts\&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n&quot;],&quot;index.ts&quot;:[0,&quot;// Dynamically load Phaser, then run the game code\nfunction loadPhaserAndRun(main) {\n  if (window.Phaser) return main();\n  var script = document.createElement(\&quot;script\&quot;);\n  script.src = \&quot;https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js\&quot;;\n  script.onload = main;\n  document.head.appendChild(script);\n}\n\nloadPhaserAndRun(function () {\n  const tileSize = 48;\n  const maxWidth = 1280;\n  const maxHeight = 800;\n\n  function getResponsiveConfig() {\n    const width = Math.min(window.innerWidth, maxWidth);\n    const height = Math.min(window.innerHeight, maxHeight);\n    return { width, height };\n  }\n\n  const { width, height } = getResponsiveConfig();\n\n  const config = {\n    type: Phaser.AUTO,\n    parent: \&quot;game-container\&quot;,\n    width,\n    height,\n    backgroundColor: \&quot;#333\&quot;,\n    scale: {\n      mode: Phaser.Scale.FIT,\n      autoCenter: Phaser.Scale.CENTER_BOTH,\n    },\n    scene: {\n      preload,\n      create,\n      update,\n    },\n    physics: {\n      default: \&quot;arcade\&quot;,\n      arcade: { debug: false },\n    },\n  };\n\n  let player;\n  let camera;\n  let gridGraphics;\n  let debugText;\n  let gridPixelWidth = 0;\n  let gridPixelHeight = 0;\n\n  function preload() {\n    // Placeholder: load a simple square as player\n    this.textures.generate(\&quot;player\&quot;, { data: [\&quot;3\&quot;], pixelWidth: tileSize });\n  }\n\n  function drawGrid(gfx, width, height, tileSize) {\n    gfx.clear();\n    gfx.lineStyle(1, 0x888888, 0.5);\n    gridPixelWidth = Math.round(width);\n    gridPixelHeight = Math.round(height);\n    // Vertical lines\n    for (let x = 0; x &lt;= width; x += tileSize) {\n      gfx.beginPath();\n      gfx.moveTo(x, 0);\n      gfx.lineTo(x, height);\n      gfx.strokePath();\n    }\n    // Horizontal lines\n    for (let y = 0; y &lt;= height; y += tileSize) {\n      gfx.beginPath();\n      gfx.moveTo(0, y);\n      gfx.lineTo(width, y);\n      gfx.strokePath();\n    }\n  }\n\n  function create() {\n    // Add grid graphics\n    gridGraphics = this.add.graphics();\n\n    // Initialize camera before using it\n    camera = this.cameras.main;\n\n    // Mouse/touch zoom event listeners (after camera is initialized)\n    const minZoom = 0.5;\n    const maxZoom = 2.0;\n    let lastPinchDist: number | null = null;\n    setTimeout(() =&gt; {\n      const gameContainer = document.getElementById(\&quot;game-container\&quot;);\n      if (gameContainer) {\n        // Mouse wheel zoom\n        gameContainer.addEventListener(\n          \&quot;wheel\&quot;,\n          (event) =&gt; {\n            if (!camera) return;\n            event.preventDefault();\n            let newZoom = camera.zoom;\n            if (event.deltaY &lt; 0) {\n              newZoom *= 1.1;\n            } else {\n              newZoom /= 1.1;\n            }\n            newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));\n            camera.setZoom(newZoom);\n          },\n          { passive: false }\n        );\n        // Pinch-to-zoom\n        gameContainer.addEventListener(\&quot;touchstart\&quot;, (e) =&gt; {\n          if (e.touches.length === 2) {\n            const dx = e.touches[0].clientX - e.touches[1].clientX;\n            const dy = e.touches[0].clientY - e.touches[1].clientY;\n            lastPinchDist = Math.sqrt(dx * dx + dy * dy);\n          }\n        });\n        gameContainer.addEventListener(\n          \&quot;touchmove\&quot;,\n          (e) =&gt; {\n            if (e.touches.length === 2 &amp;&amp; lastPinchDist !== null) {\n              const dx = e.touches[0].clientX - e.touches[1].clientX;\n              const dy = e.touches[0].clientY - e.touches[1].clientY;\n              const newDist = Math.sqrt(dx * dx + dy * dy);\n              let newZoom = camera.zoom * (newDist / lastPinchDist);\n              newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));\n              camera.setZoom(newZoom);\n              lastPinchDist = newDist;\n              e.preventDefault();\n            }\n          },\n          { passive: false }\n        );\n        gameContainer.addEventListener(\&quot;touchend\&quot;, (e) =&gt; {\n          if (e.touches.length &lt; 2) {\n            lastPinchDist = null;\n          }\n        });\n      }\n    }, 0);\n    // Add grid graphics\n    gridGraphics = this.add.graphics();\n\n    // Initialize camera before using it\n    camera = this.cameras.main;\n\n    // Initial zoom calculation (revert to 8 tiles)\n    function setMinTileZoomAndPlayer(useCameraDisplay = false) {\n      const minTiles = 8;\n      // Use camera.displayWidth/displayHeight only after resize, otherwise use this.scale.width/height\n      const viewWidth = useCameraDisplay\n        ? camera.displayWidth\n        : this.scale.width;\n      const viewHeight = useCameraDisplay\n        ? camera.displayHeight\n        : this.scale.height;\n      // If container can fit at least 8 tiles at zoom 1.0, use zoom 1.0\n      let zoom;\n      if (\n        viewWidth &gt;= tileSize * minTiles &amp;&amp;\n        viewHeight &gt;= tileSize * minTiles\n      ) {\n        zoom = 1.0;\n        camera.setZoom(zoom);\n      } else {\n        // Otherwise, reduce zoom to fit at least 8 tiles\n        let zoomX = viewWidth / (tileSize * minTiles);\n        let zoomY = viewHeight / (tileSize * minTiles);\n        zoom = Math.min(zoomX, zoomY);\n        // Adjust zoom so that floor(viewHeight / (tileSize * zoom)) &gt;= minTiles\n        while (Math.floor(viewHeight / (tileSize * zoom)) &lt; minTiles) {\n          zoom *= 0.99; // decrease zoom slightly until enough tiles fit\n        }\n        while (Math.floor(viewWidth / (tileSize * zoom)) &lt; minTiles) {\n          zoom *= 0.99;\n        }\n        camera.setZoom(zoom);\n      }\n      // Draw grid 2 tiles wider and higher than visible area\n      const gridWidth = viewWidth / zoom + tileSize * 2;\n      const gridHeight = viewHeight / zoom + tileSize * 2;\n      drawGrid(gridGraphics, gridWidth, gridHeight, tileSize);\n\n      // Calculate most centered grid cell in the drawn grid\n      const cols = Math.floor(gridWidth / tileSize);\n      const rows = Math.floor(gridHeight / tileSize);\n      const centerCol = Math.floor(cols / 2);\n      const centerRow = Math.floor(rows / 2);\n      const centerX = centerCol * tileSize + tileSize / 2;\n      const centerY = centerRow * tileSize + tileSize / 2;\n\n      // Add or move player sprite in most centered grid cell\n      if (!player) {\n        player = this.physics.add.sprite(centerX, centerY, \&quot;player\&quot;);\n        player.setDisplaySize(tileSize, tileSize);\n        player.setCollideWorldBounds(true);\n        camera.startFollow(player, true, 0.1, 0.1);\n      } else {\n        player.x = centerX;\n        player.y = centerY;\n      }\n    }\n    setMinTileZoomAndPlayer.call(this, false);\n\n    // Add debug text object\n    debugText = this.add\n      .text(8, 8, \&quot;\&quot;, {\n        font: \&quot;16px monospace\&quot;,\n        fill: \&quot;#ff4444\&quot;,\n        backgroundColor: \&quot;rgba(0,0,0,0.5)\&quot;,\n        padding: { x: 8, y: 4 },\n        align: \&quot;left\&quot;,\n        fixedWidth: 400,\n      })\n      .setScrollFactor(0);\n\n    // Handle window resize\n    window.addEventListener(\&quot;resize\&quot;, () =&gt; {\n      const { width: newWidth, height: newHeight } = getResponsiveConfig();\n      this.scale.resize(newWidth, newHeight);\n      setTimeout(() =&gt; {\n        setMinTileZoomAndPlayer.call(this, true);\n      }, 0);\n    });\n  }\n\n  function update() {\n    // Print debug info\n    if (debugText &amp;&amp; camera) {\n      const zoom = camera.zoom;\n      const fullTilesX = Math.floor(camera.displayWidth / tileSize);\n      const fullTilesY = Math.floor(camera.displayHeight / tileSize);\n      const visibleGridState = {\n        cameraDisplayWidth: camera.displayWidth,\n        cameraDisplayHeight: camera.displayHeight,\n        tileSize,\n        fullTilesX,\n        fullTilesY,\n        gridPixelWidth,\n        gridPixelHeight,\n        zoom,\n        configWidth: width,\n        configHeight: height,\n        windowWidth: window.innerWidth,\n        windowHeight: window.innerHeight,\n      };\n      let debugStr =\n        `Container: ${window.innerWidth} x ${window.innerHeight}\\n` +\n        `Max Game World: ${maxWidth} x ${maxHeight}\\n` +\n        `Visible Game World: ${camera.displayWidth.toFixed(\n          0\n        )} x ${camera.displayHeight.toFixed(0)}\\n`;\n      debugStr +=\n        `Total Grid: ${Math.floor(gridPixelWidth / tileSize)} x ${Math.floor(\n          gridPixelHeight / tileSize\n        )}\\n` +\n        `Visible Grid: ${fullTilesX} x ${fullTilesY}\\n` +\n        `Camera Zoom: ${zoom.toFixed(2)}`;\n      debugText.setText(debugStr);\n    }\n  }\n\n  new Phaser.Game(config);\n});\n&quot;]}]}]}" ssr client="only" opts="{&quot;name&quot;:&quot;React_Code&quot;,&quot;value&quot;:&quot;react&quot;}"></astro-island>
<h3 id="movement-and-block-placement">Movement and Block Placement</h3>
<astro-island uid="Z1jEcGo" component-url="/bd-25/_astro/Code.kjOHE-K0.js" component-export="default" renderer-url="/bd-25/_astro/client.BIF7rNY7.js" props="{&quot;src&quot;:[0,{&quot;vanilla-ts&quot;:[0,{&quot;index.html&quot;:[0,&quot;&lt;!DOCTYPE html&gt;\n&lt;html lang=\&quot;en\&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=\&quot;UTF-8\&quot; /&gt;\n    &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1.0\&quot; /&gt;\n    &lt;title&gt;Movement and Block Placement - Phaser&lt;/title&gt;\n    &lt;style&gt;\n      html,\n      body {\n        height: 100%;\n        margin: 0;\n        padding: 0;\n        background: #222;\n        overflow: hidden;\n      }\n      #game-container {\n        width: 100vw;\n        height: 100vh;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body style=\&quot;margin: 0; padding: 0\&quot;&gt;\n    &lt;div id=\&quot;game-container\&quot;&gt;&lt;/div&gt;\n    &lt;script src=\&quot;index.ts\&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n&quot;],&quot;index.ts&quot;:[0,&quot;// Dynamically load Phaser, then run the game code\nfunction loadPhaserAndRun(main) {\n  if (window.Phaser) return main();\n  var script = document.createElement(\&quot;script\&quot;);\n  script.src = \&quot;https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js\&quot;;\n  script.onload = main;\n  document.head.appendChild(script);\n}\n\n// @ts-ignore: Phaser is loaded dynamically\ndeclare var Phaser: any;\nloadPhaserAndRun(function () {\n  let player: any;\n  let isDragging = false;\n  let target: { x: number; y: number } | null = null;\n  const moveSpeed = 248; // pixels per second\n  const tileSize = 48;\n  const gridWidth = 20;\n  const gridHeight = 15;\n\n  // Animation frame rate calculation\n  const animFrameRate = Math.max(4, Math.min(12, Math.round(moveSpeed / 32)));\n\n  // Game state\n  const worldTiles: number[][] = Array.from({ length: gridWidth }, () =&gt;\n    Array(gridHeight).fill(0)\n  );\n\n  // Highlighted tiles around player\n  let highlightedTiles: any[] = [];\n  let debugBoundingBox: any = null; // Debug rectangle to show player bounds\n  let gameScene: any;\n\n  function preload() {\n    // Load the &#39;dude&#39; sprite sheet for player\n    this.load.spritesheet(\n      \&quot;player\&quot;,\n      \&quot;https://labs.phaser.io/assets/sprites/dude.png\&quot;,\n      {\n        frameWidth: 32,\n        frameHeight: 48,\n      }\n    );\n\n    // Load block sprite for placement\n    this.load.image(\&quot;block\&quot;, \&quot;https://labs.phaser.io/assets/sprites/block.png\&quot;);\n  }\n\n  function create() {\n    gameScene = this;\n\n    // Create player at center of screen\n    player = this.add.sprite(\n      this.sys.game.config.width / 2,\n      this.sys.game.config.height / 2,\n      \&quot;player\&quot;\n    );\n    player.setScale(2);\n    player.setDepth(100); // Ensure player is rendered above blocks\n\n    // Define walking and idle animations\n    this.anims.create({\n      key: \&quot;left\&quot;,\n      frames: this.anims.generateFrameNumbers(\&quot;player\&quot;, { start: 0, end: 3 }),\n      frameRate: animFrameRate,\n      repeat: -1,\n    });\n    this.anims.create({\n      key: \&quot;turn\&quot;,\n      frames: [{ key: \&quot;player\&quot;, frame: 4 }],\n      frameRate: Math.max(2, Math.round(animFrameRate * 2)),\n    });\n    this.anims.create({\n      key: \&quot;right\&quot;,\n      frames: this.anims.generateFrameNumbers(\&quot;player\&quot;, { start: 5, end: 8 }),\n      frameRate: animFrameRate,\n      repeat: -1,\n    });\n    this.anims.create({\n      key: \&quot;up\&quot;,\n      frames: this.anims.generateFrameNumbers(\&quot;player\&quot;, { start: 0, end: 3 }),\n      frameRate: animFrameRate,\n      repeat: -1,\n    });\n    this.anims.create({\n      key: \&quot;down\&quot;,\n      frames: this.anims.generateFrameNumbers(\&quot;player\&quot;, { start: 5, end: 8 }),\n      frameRate: animFrameRate,\n      repeat: -1,\n    });\n\n    // Draw grid lines for clarity\n    for (let x = 0; x &lt;= gridWidth; x++) {\n      this.add\n        .line(\n          0,\n          0,\n          x * tileSize,\n          0,\n          x * tileSize,\n          gridHeight * tileSize,\n          0x444444\n        )\n        .setOrigin(0)\n        .setAlpha(0.3);\n    }\n    for (let y = 0; y &lt;= gridHeight; y++) {\n      this.add\n        .line(\n          0,\n          0,\n          0,\n          y * tileSize,\n          gridWidth * tileSize,\n          y * tileSize,\n          0x444444\n        )\n        .setOrigin(0)\n        .setAlpha(0.3);\n    }\n\n    // Initial highlight of tiles around player\n    updateHighlightedTiles();\n\n    // Handle drag movement\n    const canvas = this.sys.game.canvas;\n    let pointerMoveHandler: ((ev: PointerEvent) =&gt; void) | null = null;\n    let pointerUpHandler: (() =&gt; void) | null = null;\n\n    canvas.addEventListener(\&quot;pointerdown\&quot;, (e) =&gt; {\n      const worldX = e.offsetX;\n      const worldY = e.offsetY;\n      const tileX = Math.floor(worldX / tileSize);\n      const tileY = Math.floor(worldY / tileSize);\n\n      // Check if clicking on a highlighted tile for block placement\n      if (isHighlightedTile(tileX, tileY)) {\n        placeBlock(tileX, tileY);\n        return;\n      }\n\n      // Otherwise start dragging\n      isDragging = true;\n      target = { x: worldX, y: worldY };\n\n      pointerMoveHandler = (ev: PointerEvent) =&gt; {\n        if (isDragging) {\n          target = { x: ev.offsetX, y: ev.offsetY };\n        }\n      };\n      canvas.addEventListener(\&quot;pointermove\&quot;, pointerMoveHandler);\n\n      pointerUpHandler = () =&gt; {\n        isDragging = false;\n        target = null;\n        if (pointerMoveHandler)\n          canvas.removeEventListener(\&quot;pointermove\&quot;, pointerMoveHandler);\n        if (pointerUpHandler)\n          canvas.removeEventListener(\&quot;pointerup\&quot;, pointerUpHandler);\n      };\n      canvas.addEventListener(\&quot;pointerup\&quot;, pointerUpHandler);\n    });\n  }\n\n  function getPlayerOccupiedTiles(): Array&lt;{ x: number; y: number }&gt; {\n    // Adjust bounding box to match visible sprite size more accurately\n    // Custom adjustments for better collision detection\n    const baseWidth = 24 * 2; // 48px base\n    const baseHeight = 36 * 2; // 72px base\n\n    // Apply custom adjustments: 3px left, 1px right, -1px top, +11px bottom\n    const left = player.x - baseWidth / 2 - 3; // 3 pixels wider to the left (was 2)\n    const right = player.x + baseWidth / 2 + 1; // 1 pixel wider to the right\n    const top = player.y - baseHeight / 2 + 1; // 1 pixel smaller from the top\n    const bottom = player.y + baseHeight / 2 + 11; // 11 pixels bigger to the bottom (was 6)\n\n    // Find all tiles that the player overlaps\n    const occupiedTiles: Array&lt;{ x: number; y: number }&gt; = [];\n    const leftTile = Math.floor(left / tileSize);\n    const rightTile = Math.floor(right / tileSize);\n    const topTile = Math.floor(top / tileSize);\n    const bottomTile = Math.floor(bottom / tileSize);\n\n    for (let x = leftTile; x &lt;= rightTile; x++) {\n      for (let y = topTile; y &lt;= bottomTile; y++) {\n        if (x &gt;= 0 &amp;&amp; x &lt; gridWidth &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; gridHeight) {\n          occupiedTiles.push({ x, y });\n        }\n      }\n    }\n\n    return occupiedTiles;\n  }\n  function updateHighlightedTiles() {\n    // Clear existing highlights and debug box\n    highlightedTiles.forEach((tile) =&gt; tile.destroy());\n    highlightedTiles = [];\n    if (debugBoundingBox) {\n      debugBoundingBox.destroy();\n      debugBoundingBox = null;\n    }\n\n    // Calculate and draw debug bounding box with custom adjustments\n    const baseWidth = 24 * 2; // 48px base\n    const baseHeight = 36 * 2; // 72px base\n\n    // Apply same adjustments as collision detection: 3px left, 1px right, -1px top, +11px bottom\n    const left = player.x - baseWidth / 2 - 3;\n    const right = player.x + baseWidth / 2 + 1;\n    const top = player.y - baseHeight / 2 + 1;\n    const bottom = player.y + baseHeight / 2 + 11;\n\n    // Calculate center and dimensions for the rectangle\n    const rectCenterX = (left + right) / 2;\n    const rectCenterY = (top + bottom) / 2;\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    debugBoundingBox = gameScene.add.rectangle(\n      rectCenterX,\n      rectCenterY,\n      rectWidth,\n      rectHeight,\n      0xff0000,\n      0 // transparent fill\n    );\n    debugBoundingBox.setStrokeStyle(2, 0xff0000); // red border\n    debugBoundingBox.setDepth(150); // Above everything else for debugging\n\n    // Get tiles occupied by player\n    const occupiedTiles = getPlayerOccupiedTiles();\n    const occupiedSet = new Set(occupiedTiles.map((t) =&gt; `${t.x},${t.y}`));\n\n    // Get all tiles around the occupied area\n    const tilesToCheck = new Set&lt;string&gt;();\n    occupiedTiles.forEach((tile) =&gt; {\n      for (let dx = -1; dx &lt;= 1; dx++) {\n        for (let dy = -1; dy &lt;= 1; dy++) {\n          const tileX = tile.x + dx;\n          const tileY = tile.y + dy;\n          if (\n            tileX &gt;= 0 &amp;&amp;\n            tileX &lt; gridWidth &amp;&amp;\n            tileY &gt;= 0 &amp;&amp;\n            tileY &lt; gridHeight\n          ) {\n            tilesToCheck.add(`${tileX},${tileY}`);\n          }\n        }\n      }\n    });\n\n    // Highlight neighboring tiles that are not occupied by player\n    tilesToCheck.forEach((tileKey) =&gt; {\n      if (!occupiedSet.has(tileKey)) {\n        const [tileX, tileY] = tileKey.split(\&quot;,\&quot;).map(Number);\n\n        // Check if tile is empty\n        if (worldTiles[tileX][tileY] === 0) {\n          // Create highlight rectangle\n          const highlight = gameScene.add.rectangle(\n            tileX * tileSize + tileSize / 2,\n            tileY * tileSize + tileSize / 2,\n            tileSize,\n            tileSize,\n            0x00ff00,\n            0.3\n          );\n          highlight.setStrokeStyle(2, 0x00ff00);\n          highlight.setDepth(50); // Above blocks but below player\n          highlightedTiles.push(highlight);\n        }\n      }\n    });\n  }\n\n  function isHighlightedTile(tileX: number, tileY: number): boolean {\n    // Get tiles occupied by player\n    const occupiedTiles = getPlayerOccupiedTiles();\n    const occupiedSet = new Set(occupiedTiles.map((t) =&gt; `${t.x},${t.y}`));\n\n    // Check if this tile is occupied by player\n    if (occupiedSet.has(`${tileX},${tileY}`)) {\n      return false;\n    }\n\n    // Check if this tile is neighboring any occupied tile\n    for (const occupiedTile of occupiedTiles) {\n      const dx = Math.abs(tileX - occupiedTile.x);\n      const dy = Math.abs(tileY - occupiedTile.y);\n      if (dx &lt;= 1 &amp;&amp; dy &lt;= 1) {\n        // This tile is neighboring an occupied tile, check if it&#39;s empty\n        return (\n          tileX &gt;= 0 &amp;&amp;\n          tileX &lt; gridWidth &amp;&amp;\n          tileY &gt;= 0 &amp;&amp;\n          tileY &lt; gridHeight &amp;&amp;\n          worldTiles[tileX][tileY] === 0\n        );\n      }\n    }\n\n    return false;\n  }\n\n  function placeBlock(tileX: number, tileY: number) {\n    if (\n      tileX &gt;= 0 &amp;&amp;\n      tileX &lt; gridWidth &amp;&amp;\n      tileY &gt;= 0 &amp;&amp;\n      tileY &lt; gridHeight &amp;&amp;\n      worldTiles[tileX][tileY] === 0\n    ) {\n      worldTiles[tileX][tileY] = 1;\n\n      // Add a block sprite underneath the player\n      const block = gameScene.add.sprite(\n        tileX * tileSize + tileSize / 2,\n        tileY * tileSize + tileSize / 2,\n        \&quot;block\&quot;\n      );\n      block.displayWidth = tileSize;\n      block.displayHeight = tileSize;\n      block.setDepth(10); // Below player and highlights\n\n      // Update highlights since the grid changed\n      updateHighlightedTiles();\n    }\n  }\n\n  function update(time: number, delta: number) {\n    const previousPlayerX = player.x;\n    const previousPlayerY = player.y;\n\n    if (isDragging &amp;&amp; target) {\n      const dx = target.x - player.x;\n      const dy = target.y - player.y;\n      const step = moveSpeed * (delta / 1000);\n      const snapThreshold = 2; // pixels\n\n      // Always walk horizontally first, then vertically\n      if (Math.abs(dx) &gt; snapThreshold) {\n        // Move horizontally only\n        if (Math.abs(dx) &lt; step) {\n          player.x = target.x;\n        } else {\n          player.x += step * Math.sign(dx);\n        }\n        // Play horizontal animation\n        if (dx &lt; 0) {\n          player.anims.play(\&quot;left\&quot;, true);\n        } else {\n          player.anims.play(\&quot;right\&quot;, true);\n        }\n      } else if (Math.abs(dy) &gt; snapThreshold) {\n        // Only move vertically after horizontal is done\n        if (Math.abs(dy) &lt; step) {\n          player.y = target.y;\n        } else {\n          player.y += step * Math.sign(dy);\n        }\n        // Play vertical animation\n        if (dy &lt; 0) {\n          player.anims.play(\&quot;up\&quot;, true);\n        } else {\n          player.anims.play(\&quot;down\&quot;, true);\n        }\n      } else {\n        // Snap to target and idle\n        player.x = target.x;\n        player.y = target.y;\n        player.anims.play(\&quot;turn\&quot;);\n      }\n    } else {\n      // Not moving, idle\n      if (player &amp;&amp; player.anims) player.anims.play(\&quot;turn\&quot;);\n    }\n\n    // Update highlighted tiles whenever player moves or is dragging\n    // Since player can span multiple tiles, we need frequent updates\n    if (\n      isDragging ||\n      Math.abs(player.x - previousPlayerX) &gt; 0 ||\n      Math.abs(player.y - previousPlayerY) &gt; 0\n    ) {\n      updateHighlightedTiles();\n    }\n  }\n\n  const config = {\n    type: Phaser.AUTO,\n    width: Math.min(window.innerWidth, tileSize * gridWidth),\n    height: Math.min(window.innerHeight, tileSize * gridHeight),\n    backgroundColor: \&quot;#87ceeb\&quot;,\n    parent: \&quot;game-container\&quot;,\n    scene: {\n      preload,\n      create,\n      update,\n    },\n  };\n\n  new Phaser.Game(config);\n});\n&quot;]}]}]}" ssr client="only" opts="{&quot;name&quot;:&quot;React_Code&quot;,&quot;value&quot;:&quot;react&quot;}"></astro-island>
<h3 id="drag-to-move">Drag to Move</h3>
<astro-island uid="149cKQ" component-url="/bd-25/_astro/Code.kjOHE-K0.js" component-export="default" renderer-url="/bd-25/_astro/client.BIF7rNY7.js" props="{&quot;src&quot;:[0,{&quot;vanilla-ts&quot;:[0,{&quot;index.html&quot;:[0,&quot;&lt;!DOCTYPE html&gt;\n&lt;html lang=\&quot;en\&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=\&quot;UTF-8\&quot; /&gt;\n    &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1.0\&quot; /&gt;\n    &lt;title&gt;Drag to Move Example - Phaser&lt;/title&gt;\n    &lt;style&gt;\n      html,\n      body {\n        height: 100%;\n        margin: 0;\n        padding: 0;\n        background: #222;\n        overflow: hidden;\n      }\n      #game-container {\n        width: 100vw;\n        height: 100vh;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body style=\&quot;margin: 0; padding: 0\&quot;&gt;\n    &lt;div id=\&quot;game-container\&quot;&gt;&lt;/div&gt;\n    &lt;script src=\&quot;index.ts\&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n&quot;],&quot;index.ts&quot;:[0,&quot;// Dynamically load Phaser, then run the game code\nfunction loadPhaserAndRun(main) {\n  if (window.Phaser) return main();\n  var script = document.createElement(\&quot;script\&quot;);\n  script.src = \&quot;https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js\&quot;;\n  script.onload = main;\n  document.head.appendChild(script);\n}\n\n// @ts-ignore: Phaser is loaded dynamically\ndeclare var Phaser: any;\nloadPhaserAndRun(function () {\n  let player: any;\n  let isDragging = false;\n  let target: { x: number; y: number } | null = null;\n  const moveSpeed = 248; // pixels per second (e.g., 96px = 1.5 tiles/sec if tile is 64px)\n  // Animation frame rate calculation: higher moveSpeed = faster animation, but clamped to 4‚Äì12 fps\n  const animFrameRate = Math.max(4, Math.min(12, Math.round(moveSpeed / 32)));\n\n  function preload() {\n    // Load the &#39;dude&#39; sprite sheet (standard Phaser walking animation asset)\n    this.load.spritesheet(\n      \&quot;player\&quot;,\n      \&quot;https://labs.phaser.io/assets/sprites/dude.png\&quot;,\n      {\n        frameWidth: 32,\n        frameHeight: 48,\n      }\n    );\n  }\n\n  function create() {\n    player = this.add.sprite(\n      this.sys.game.config.width / 2,\n      this.sys.game.config.height / 2,\n      \&quot;player\&quot;\n    );\n    player.setScale(2);\n\n    // Define walking and idle animations with dynamic frameRate\n    this.anims.create({\n      key: \&quot;left\&quot;,\n      frames: this.anims.generateFrameNumbers(\&quot;player\&quot;, { start: 0, end: 3 }),\n      frameRate: animFrameRate,\n      repeat: -1,\n    });\n    this.anims.create({\n      key: \&quot;turn\&quot;,\n      frames: [{ key: \&quot;player\&quot;, frame: 4 }],\n      frameRate: Math.max(2, Math.round(animFrameRate * 2)),\n    });\n    this.anims.create({\n      key: \&quot;right\&quot;,\n      frames: this.anims.generateFrameNumbers(\&quot;player\&quot;, { start: 5, end: 8 }),\n      frameRate: animFrameRate,\n      repeat: -1,\n    });\n    // Simulate up/down animations using left/right frames\n    this.anims.create({\n      key: \&quot;up\&quot;,\n      frames: this.anims.generateFrameNumbers(\&quot;player\&quot;, { start: 0, end: 3 }), // reuse left frames\n      frameRate: animFrameRate,\n      repeat: -1,\n    });\n    this.anims.create({\n      key: \&quot;down\&quot;,\n      frames: this.anims.generateFrameNumbers(\&quot;player\&quot;, { start: 5, end: 8 }), // reuse right frames\n      frameRate: animFrameRate,\n      repeat: -1,\n    });\n\n    // Use the canvas element for pointer events for better reliability\n    const canvas = this.sys.game.canvas;\n    let pointerMoveHandler: ((ev: PointerEvent) =&gt; void) | null = null;\n    let pointerUpHandler: (() =&gt; void) | null = null;\n\n    canvas.addEventListener(\&quot;pointerdown\&quot;, (e) =&gt; {\n      isDragging = true;\n      target = { x: e.offsetX, y: e.offsetY };\n\n      pointerMoveHandler = (ev: PointerEvent) =&gt; {\n        if (isDragging) {\n          target = { x: ev.offsetX, y: ev.offsetY };\n        }\n      };\n      canvas.addEventListener(\&quot;pointermove\&quot;, pointerMoveHandler);\n\n      pointerUpHandler = () =&gt; {\n        isDragging = false;\n        target = null;\n        if (pointerMoveHandler)\n          canvas.removeEventListener(\&quot;pointermove\&quot;, pointerMoveHandler);\n        if (pointerUpHandler)\n          canvas.removeEventListener(\&quot;pointerup\&quot;, pointerUpHandler);\n      };\n      canvas.addEventListener(\&quot;pointerup\&quot;, pointerUpHandler);\n    });\n  }\n\n  function update(time: number, delta: number) {\n    if (isDragging &amp;&amp; target) {\n      const dx = target.x - player.x;\n      const dy = target.y - player.y;\n      const step = moveSpeed * (delta / 1000);\n      const snapThreshold = 2; // pixels\n\n      // Always walk horizontally first, then vertically\n      if (Math.abs(dx) &gt; snapThreshold) {\n        // Move horizontally only\n        if (Math.abs(dx) &lt; step) {\n          player.x = target.x;\n        } else {\n          player.x += step * Math.sign(dx);\n        }\n        // Play horizontal animation\n        if (dx &lt; 0) {\n          player.anims.play(\&quot;left\&quot;, true);\n        } else {\n          player.anims.play(\&quot;right\&quot;, true);\n        }\n      } else if (Math.abs(dy) &gt; snapThreshold) {\n        // Only move vertically after horizontal is done\n        if (Math.abs(dy) &lt; step) {\n          player.y = target.y;\n        } else {\n          player.y += step * Math.sign(dy);\n        }\n        // Play vertical animation\n        if (dy &lt; 0) {\n          player.anims.play(\&quot;up\&quot;, true);\n        } else {\n          player.anims.play(\&quot;down\&quot;, true);\n        }\n      } else {\n        // Snap to target and idle\n        player.x = target.x;\n        player.y = target.y;\n        player.anims.play(\&quot;turn\&quot;);\n      }\n    } else {\n      // Not moving, idle\n      if (player &amp;&amp; player.anims) player.anims.play(\&quot;turn\&quot;);\n    }\n  }\n\n  const config = {\n    type: Phaser.AUTO,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    backgroundColor: \&quot;#87ceeb\&quot;,\n    parent: \&quot;game-container\&quot;,\n    scene: {\n      preload,\n      create,\n      update,\n    },\n  };\n\n  new Phaser.Game(config);\n});\n&quot;]}]}]}" ssr client="only" opts="{&quot;name&quot;:&quot;React_Code&quot;,&quot;value&quot;:&quot;react&quot;}"></astro-island>
<h3 id="block-placement">Block Placement</h3>
<astro-island uid="1FqJOJ" component-url="/bd-25/_astro/Code.kjOHE-K0.js" component-export="default" renderer-url="/bd-25/_astro/client.BIF7rNY7.js" props="{&quot;src&quot;:[0,{&quot;vanilla-ts&quot;:[0,{&quot;index.html&quot;:[0,&quot;&lt;!DOCTYPE html&gt;\n&lt;html lang=\&quot;en\&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=\&quot;UTF-8\&quot; /&gt;\n    &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1.0\&quot; /&gt;\n    &lt;title&gt;Block Placement Example - Phaser&lt;/title&gt;\n    &lt;style&gt;\n      html,\n      body {\n        height: 100%;\n        margin: 0;\n        padding: 0;\n        background: #222;\n        overflow: hidden;\n      }\n      #game-container {\n        width: 100vw;\n        height: 100vh;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body style=\&quot;margin: 0; padding: 0\&quot;&gt;\n    &lt;div id=\&quot;game-container\&quot;&gt;&lt;/div&gt;\n    &lt;script src=\&quot;index.ts\&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n&quot;],&quot;index.ts&quot;:[0,&quot;// Type-only import for Phaser types\nimport type PhaserType from \&quot;phaser\&quot;;\n\n// Module context for global augmentation\nexport {};\ndeclare global {\n  interface Window {\n    Phaser?: typeof PhaserType;\n  }\n}\n\n// Dynamically load Phaser, then run the game code\nfunction loadPhaserAndRun(main: () =&gt; void): void {\n  if (window.Phaser) return main();\n  const script = document.createElement(\&quot;script\&quot;);\n  script.src = \&quot;https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js\&quot;;\n  script.onload = main;\n  document.head.appendChild(script);\n}\n\nloadPhaserAndRun(() =&gt; {\n  const tileSize = 48;\n  const gridWidth = 10;\n  const gridHeight = 8;\n  // 0 = empty, 1 = block\n  const worldTiles: number[][] = Array.from({ length: gridWidth }, () =&gt;\n    Array(gridHeight).fill(0)\n  );\n\n  // Use PhaserType for type checking\n  type SceneType = PhaserType.Scene;\n\n  function preload(this: SceneType): void {\n    this.load.image(\&quot;block\&quot;, \&quot;https://labs.phaser.io/assets/sprites/block.png\&quot;);\n  }\n\n  function create(this: SceneType): void {\n    this.input.on(\&quot;pointerdown\&quot;, (pointer: any) =&gt; {\n      // Use &#39;any&#39; for pointer since Phaser types may not be available at runtime\n      const tileX = Math.floor(pointer.worldX / tileSize);\n      const tileY = Math.floor(pointer.worldY / tileSize);\n      if (\n        tileX &gt;= 0 &amp;&amp;\n        tileX &lt; gridWidth &amp;&amp;\n        tileY &gt;= 0 &amp;&amp;\n        tileY &lt; gridHeight &amp;&amp;\n        worldTiles[tileX][tileY] === 0\n      ) {\n        worldTiles[tileX][tileY] = 1;\n        // Add a block sprite that fills the tile (48x48)\n        const block = this.add.sprite(\n          tileX * tileSize + tileSize / 2,\n          tileY * tileSize + tileSize / 2,\n          \&quot;block\&quot;\n        );\n        block.displayWidth = tileSize;\n        block.displayHeight = tileSize;\n      }\n    });\n    // Draw grid lines for clarity\n    for (let x = 0; x &lt;= gridWidth; x++) {\n      this.add\n        .line(\n          0,\n          0,\n          x * tileSize,\n          0,\n          x * tileSize,\n          gridHeight * tileSize,\n          0x888888\n        )\n        .setOrigin(0);\n    }\n    for (let y = 0; y &lt;= gridHeight; y++) {\n      this.add\n        .line(\n          0,\n          0,\n          0,\n          y * tileSize,\n          gridWidth * tileSize,\n          y * tileSize,\n          0x888888\n        )\n        .setOrigin(0);\n    }\n  }\n\n  // Use PhaserType for config typing\n  const config: PhaserType.Types.Core.GameConfig = {\n    type: window.Phaser ? window.Phaser.AUTO : 0,\n    width: tileSize * gridWidth,\n    height: tileSize * gridHeight,\n    backgroundColor: \&quot;#bada55\&quot;,\n    parent: \&quot;game-container\&quot;,\n    scene: {\n      preload,\n      create,\n    },\n  };\n\n  // @ts-ignore: Phaser is loaded dynamically\n  new window.Phaser!.Game(config);\n});\n&quot;]}]}]}" ssr client="only" opts="{&quot;name&quot;:&quot;React_Code&quot;,&quot;value&quot;:&quot;react&quot;}"></astro-island>
<h2 id="-references--inspirations">üìö References &amp; Inspirations</h2>
<ul>
<li><a href="https://phaser.io/">Phaser.js Documentation</a></li>
<li>Minecraft (as inspiration for block-building mechanics)</li>
<li>Stardew Valley, Zelda (for top-down design ideas)</li>
</ul>
<h2 id="-open-questions--next-steps">‚ùì Open Questions &amp; Next Steps</h2>
<ul>
<li>Expand inventory and block types.</li>
<li>Add harvesting mechanics and sound effects.</li>
<li>Design custom sprites and tiles.</li>
<li>Consider simple NPCs or animals for added fun.</li>
<li>Polish UI for block selection and inventory management.</li>
</ul> </div> </main> <div class="backdrop"></div> <div class="app-actions"> <label for="theme-toggle" class="theme-toggle unified-button" role="button" aria-roledescription="Toggle between dark and light mode" aria-label="Toggle between dark and light mode" title="Toggle between dark and light mode"> <input type="checkbox" id="theme-toggle"> <svg class="theme-toggle-icon light" width="16" height="16" viewBox="0 0 16 16" fill="currentColor"> <path d="M8 12a4 4 0 1 1 0-8 4 4 0 0 1 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path> </svg> <svg class="theme-toggle-icon dark" width="16" height="16" viewBox="0 0 16 16" fill="currentColor"> <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path> </svg> </label> <label for="mobile-menu-toggle" class="mobile-menu-toggle unified-button" role="button" aria-roledescription="Open and close the mobile menu" aria-label="Open and close the mobile menu" title="Open and close the mobile menu"> <input type="checkbox" id="mobile-menu-toggle"> <span class="mobile-menu-toggle-icon closed">‚ò∞</span> <span class="mobile-menu-toggle-icon opened">‚úï</span> </label> </div> </div> </body></html>