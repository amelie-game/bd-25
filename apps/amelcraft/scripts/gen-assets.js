// scripts/gen-assets.ts
// Run with: npx ts-node scripts/gen-assets.ts
const fs = require("fs");
const path = require("path");

const root = path.resolve(__dirname, "..");
const packPath = path.join(root, "assets/pack.json");
const outPath = path.join(root, "src/assets.ts");
console.log("Writing assets to:", outPath);

const pack = JSON.parse(fs.readFileSync(packPath, "utf8"));

function normalizeKey(name) {
  // PascalCase, remove dashes/underscores, capitalize each part
  return name.replace(/(^|[-_])(\w)/g, (_, __, c) => c.toUpperCase());
}

function extractAnimationsAndSprites(aseprite) {
  const result = {};
  if (!aseprite) return result;
  const { frames, meta } = aseprite;
  const usedFrames = new Set();
  // Animations from frameTags
  if (meta && Array.isArray(meta.frameTags) && meta.frameTags.length > 0) {
    result.animations = {};
    for (const tag of meta.frameTags) {
      const norm = normalizeKey(tag.name);
      result.animations[norm] = tag.name;
      // Mark frames in this tag as used
      for (let i = tag.from; i <= tag.to; i++) usedFrames.add(i.toString());
    }
  }
  // Sprites: frames not used in any animation
  const staticFrames = Object.keys(frames).filter((k) => !usedFrames.has(k));
  if (staticFrames.length > 0) {
    result.sprites = {};
    for (const k of staticFrames) {
      const frame = frames[k];
      if (frame && typeof frame === "object" && frame.name) {
        // Use the 'name' property as the key, and the frame index as the value
        const norm = normalizeKey(frame.name);
        result.sprites[norm] = k;
      } else {
        // Fallback: use the key as both key and value (legacy)
        const norm = normalizeKey(k);
        result.sprites[norm] = k;
      }
    }
  }
  return result;
}

const assetsObj = {};
for (const entry of pack.files) {
  if ((entry.type === "atlas" || entry.type === "aseprite") && entry.atlasURL) {
    const fullPath = path.join(root, entry.atlasURL);
    if (!fs.existsSync(fullPath)) continue;
    const aseprite = JSON.parse(fs.readFileSync(fullPath, "utf8"));
    const extracted = extractAnimationsAndSprites(aseprite);
    if (Object.keys(extracted).length > 0) {
      assetsObj[entry.key] = { key: entry.key, ...extracted };
    }
  } else if (entry.type === "spritesheet") {
    if (entry.atlasURL) {
      const fullPath = path.join(root, entry.atlasURL);
      if (fs.existsSync(fullPath)) {
        const aseprite = JSON.parse(fs.readFileSync(fullPath, "utf8"));
        const extracted = extractAnimationsAndSprites(aseprite);
        if (Object.keys(extracted).length > 0) {
          assetsObj[entry.key] = { key: entry.key, ...extracted };
        }
        continue;
      }
    }
    // If no atlasURL or not found, keep the raw entry
    assetsObj[entry.key] = { key: entry.key, ...entry };
  }
}

const fileContent = `// This file is auto-generated by scripts/gen-assets.js\n// Do not edit manually.\n\nexport const assets = ${JSON.stringify(
  assetsObj,
  null,
  2
)} as const;\n`;

fs.writeFileSync(outPath, fileContent);
console.log("Generated src/assets.ts");
