// scripts/gen-assets.ts
// Run with: npx ts-node scripts/gen-assets.ts
const fs = require("fs");
const path = require("path");

const root = path.resolve(__dirname, "..");
const packPath = path.join(root, "assets/pack.json");
const outPath = path.join(root, "src/assets.ts");

const pack = JSON.parse(fs.readFileSync(packPath, "utf8"));

function normalizeKey(name) {
  // PascalCase, remove dashes/underscores, capitalize each part
  return name.replace(/(^|[-_])(\w)/g, (_, __, c) => c.toUpperCase());
}

function extractAnimationsAndSprites(aseprite) {
  const result = {};
  if (!aseprite) return result;
  const { frames, meta } = aseprite;
  const usedFrames = new Set();
  // Animations from frameTags
  if (meta && Array.isArray(meta.frameTags) && meta.frameTags.length > 0) {
    result.animations = {};
    for (const tag of meta.frameTags) {
      const norm = normalizeKey(tag.name);
      result.animations[norm] = tag.name;
      // Mark frames in this tag as used
      for (let i = tag.from; i <= tag.to; i++) usedFrames.add(i);
    }
  }
  // Sprites: frames not used in any animation
  let staticFrames = [];
  if (Array.isArray(frames)) {
    // Array form: indices are numbers
    staticFrames = frames
      .map((frame, idx) => ({ frame, idx }))
      .filter(({ idx, frame }) => !usedFrames.has(idx) && frame !== null);
    if (staticFrames.length > 0) {
      result.sprites = {};
      for (const { frame, idx } of staticFrames) {
        if (frame && typeof frame === "object" && frame.name) {
          const norm = normalizeKey(frame.name);
          result.sprites[norm] = idx;
        } else {
          // If frame is not an object or has no name, skip (shouldn't happen with nulls filtered)
          // continue;
        }
      }
    }
  } else if (frames && typeof frames === "object") {
    // Object form: keys are strings, but try to parse as numbers
    staticFrames = Object.keys(frames)
      .map((k) => ({ frame: frames[k], idx: isNaN(Number(k)) ? k : Number(k) }))
      .filter(({ idx }) => !usedFrames.has(idx));
    if (staticFrames.length > 0) {
      result.sprites = {};
      for (const { frame, idx } of staticFrames) {
        if (frame && typeof frame === "object" && frame.name) {
          const norm = normalizeKey(frame.name);
          result.sprites[norm] = idx;
        } else {
          const norm = normalizeKey(String(idx));
          result.sprites[norm] = idx;
        }
      }
    }
  }
  return result;
}

const assetsObj = {};

for (const entry of pack.files) {
  if ((entry.type === "atlas" || entry.type === "aseprite") && entry.atlasURL) {
    const fullPath = path.join(root, entry.atlasURL);
    if (!fs.existsSync(fullPath)) continue;
    const aseprite = JSON.parse(fs.readFileSync(fullPath, "utf8"));
    const extracted = extractAnimationsAndSprites(aseprite);
    if (Object.keys(extracted).length > 0) {
      assetsObj[entry.key] = { key: entry.key, ...extracted };
    }
  } else if (entry.type === "spritesheet") {
    if (entry.atlasURL) {
      const fullPath = path.join(root, entry.atlasURL);
      if (fs.existsSync(fullPath)) {
        const aseprite = JSON.parse(fs.readFileSync(fullPath, "utf8"));
        const extracted = extractAnimationsAndSprites(aseprite);
        if (Object.keys(extracted).length > 0) {
          assetsObj[entry.key] = { key: entry.key, ...extracted };
        }
        continue;
      }
    }
    // If no atlasURL or not found, keep the raw entry
    assetsObj[entry.key] = { key: entry.key, ...entry };
  } else if (entry.type === "audio") {
    if (!assetsObj.audio) {
      assetsObj.audio = {};
    }
    // Handle audio assets
    assetsObj.audio[normalizeKey(entry.key)] = entry.key;
  }
}

if (typeof pack.metadata?.audio?.groups === "object") {
  Object.entries(pack.metadata.audio.groups).forEach(([key, soundKeys]) => {
    const normalizedKey = normalizeKey(key);
    const normalizedSoundKeys = Array.isArray(soundKeys)
      ? soundKeys
          .map((k) => {
            const normalizedKey =
              typeof k === "string" ? normalizeKey(k) : null;
            if (normalizedKey && assetsObj.audio[normalizedKey]) {
              return normalizedKey;
            }

            return null;
          })
          .filter((k) => k !== null)
      : [];

    if (normalizedSoundKeys.length > 0) {
      assetsObj.audio.groups = assetsObj.audio.groups || {};
      assetsObj.audio.groups[normalizedKey] = normalizedSoundKeys;
    }
  });
}

const fileContent = `// This file is auto-generated by scripts/gen-assets.js\n// Do not edit manually.\n\nexport const assets = ${JSON.stringify(
  assetsObj,
  null,
  2
)} as const;\n`;

fs.writeFileSync(outPath, fileContent);
